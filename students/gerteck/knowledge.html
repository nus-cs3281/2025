<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="generator" content="MarkBind 5.6.0">
    <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="stylesheet" href="/2025/markbind/css/bootstrap.min.css"> <link rel="stylesheet" href="/2025/markbind/fontawesome/css/all.min.css"> <link rel="stylesheet" href="/2025/markbind/glyphicons/css/bootstrap-glyphicons.min.css"><link rel="stylesheet" href="/2025/markbind/css/codeblock-light.min.css"><link rel="stylesheet" href="/2025/markbind/css/markbind.min.css"><link rel="stylesheet" href="/2025/plugins/markbind-plugin-anchors/markbind-plugin-anchors.css"><link rel="stylesheet" href="/2025/plugins/markbind-plugin-tree/markbind-plugin-tree.css">
    
  <link rel="stylesheet" href="/2025/stylesheets/main.css">
<link rel="icon" href="/2025/favicon.ico"></head>
<script>
  const baseUrl = '/2025'
</script>
<body >
<div id="app" data-server-rendered="true"><header fixed=""><div placement="top" data-v-7c0fd418><nav class="navbar navbar-expand-md d-print-none navbar-dark bg-primary" data-v-7c0fd418><div class="container-fluid" data-v-7c0fd418><div class="navbar-left" data-v-7c0fd418><a href="/2025/index.html" title="Home" class="navbar-brand" data-v-7c0fd418>CS3281&amp;2-2025/Students</a></div> <div class="navbar-default" data-v-7c0fd418><ul class="navbar-nav me-auto mt-2 mt-lg-0" data-v-7c0fd418> <li class="nav-link dropdown" data-v-99624572><a role="button" data-bs-toggle="dropdown" class="dropdown-toggle nav-link" data-v-99624572>CS3281 <span data-v-99624572></span></a> <ul class="dropdown-menu" data-v-99624572> <li data-v-99624572><a href="/2025/index.html" class="dropdown-item" data-v-99624572>Students</a></li> <li data-v-99624572><a href="/2025/students/knowledge.html" class="dropdown-item" data-v-99624572>Knowledge</a></li> <li data-v-99624572><a href="https://nus-cs3281.github.io/2025-dashboard/?search=&amp;sort=groupTitle&amp;sortWithin=title&amp;timeframe=commit&amp;mergegroup=&amp;groupSelect=groupByAuthors&amp;breakdown=false" class="dropdown-item" data-v-99624572>Code Dashboard</a></li> <li data-v-99624572><a href="/2025/activities-dashboard.html" class="dropdown-item" data-v-99624572>Activities Dashboard</a></li></ul></li> <li class="nav-link dropdown" data-v-99624572><a role="button" data-bs-toggle="dropdown" class="dropdown-toggle nav-link" data-v-99624572>CS3282 <span data-v-99624572></span></a> <ul class="dropdown-menu" data-v-99624572> <li data-v-99624572><a href="/2025/cs3282-index.html" class="dropdown-item" data-v-99624572>Students</a></li> <li data-v-99624572><a href="/2025/students/talksSchedule.html" class="dropdown-item" data-v-99624572>Lightning Talks</a></li> <li data-v-99624572><a href="/2025/activities-dashboard.html" class="dropdown-item" data-v-99624572>Activities Dashboard</a></li></ul></li> <li data-v-7c0fd418><a href="/2025/instructions.html" class="nav-link" data-v-7c0fd418>Instructions</a></li> <li data-v-7c0fd418><a href="https://nus-cs3281.github.io/website/" class="nav-link" data-v-7c0fd418>CS3281&amp;2 Website <span data-v-7c0fd418><span aria-hidden="true" class="glyphicon glyphicon-share-alt" data-v-7c0fd418></span></span></a></li></ul></div> <ul class="navbar-nav navbar-right" data-v-7c0fd418><li data-v-7c0fd418><a href="https://github.com/nus-cs3281/2025" class="nav-link" data-v-7c0fd418><span data-v-7c0fd418><span aria-hidden="true" class="fab fa-github" data-v-7c0fd418></span></span></a></li></ul></div></nav> <div class="lower-navbar-container" style="display:none;" data-v-7c0fd418><!----> <!----></div></div></header> <div id="flex-body"><div id="content-wrapper" class="fixed-header-padding"><p>List the aspects you learned, and the resources you used to learn them, and a brief summary of each resource.</p> <h2 id="internal-tools-technology">Internal Tools/Technology<a href="#internal-tools-technology" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h2> <h3 id="how-markbind-works-overview-of-everything">How MarkBind Works (Overview of everything)<a href="#how-markbind-works-overview-of-everything" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <p>In order to make more well informed changes and tackle deeper issues, I decided to cover the whole codebase of Markbind just so I could have a much fuller understanding of how different parts worked together.</p> <p>While doing so, I used a MarkBind site to document the architecture and different packages and classes in the MarkBind codebase. The site can be viewed here: <a href="https://gerteck.github.io/mb-architecture/">https://gerteck.github.io/mb-architecture/</a></p> <h3 id="markbind-s-search-utility">Markbind's Search Utility<a href="#markbind-s-search-utility" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <h4 id="how-native-markbind-search-works">How Native MarkBind Search works<a href="#how-native-markbind-search-works" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h4> <p><strong>Collection of Title and headings in generation:</strong></p> <ul><li>We trace the website generation in <code class="hljs inline no-lang">Site/index.ts</code>.</li> <li>When building source files, during the page generation process, <code class="hljs inline no-lang">Page.collectHeadingsAndKeywords</code> records headings and keywords inside rendered page into this.headings and this.keywords respectively.</li> <li>When writing site data, the title, headings, keywords are collected into pages object.</li></ul> <p><strong>Page Generation and Vue Initialization</strong></p> <ul><li>In <code class="hljs inline no-lang">core-web/src/index.js</code>, the <code class="hljs inline no-lang">setupWithSearch()</code> updates the SearchData by collecting the pages from the site data.
<ul><li><code class="hljs inline no-lang">setupWithSearch()</code> is added as a script in the file template <code class="hljs inline no-lang">page.njk</code> used to render the HTML structure of Markbind pages.</li> <li>This file template is used during the page generation process.</li></ul></li> <li>Note also that <code class="hljs inline no-lang">VueCommonAppFactory.js</code> provides a factory function (appFactory) to set up the common data and methods for Vue application shared between server-side and client-side, and provides the common data properties and methods.
<ul><li>In particular, <code class="hljs inline no-lang">searchData[]</code> and <code class="hljs inline no-lang">searchCallback()</code>, which are relevant in the following portion.</li> <li>When using <code class="hljs inline no-lang">&lt;searchbar/&gt;</code>, this is where to use MarkBind's search functionality, we set the appropriate values: <code class="hljs inline no-lang"> &lt;searchbar :data=&quot;searchData&quot; :on-hit=&quot;searchCallback&quot;&gt;&lt;/searchbar&gt;</code></li></ul></li></ul> <p><strong>Vue Components: Searchbar/SearchbarPageItem.vue</strong> <strong>Searchbar.vue</strong></p> <ul><li>The searchbar uses the <code class="hljs inline no-lang">searchData[]</code> in <code class="hljs inline no-lang">data</code>, filters and ranks the data based on keyword matches and populates the dropdown with <code class="hljs inline no-lang">searchbarPageItems</code>.</li> <li>It calls the <code class="hljs inline no-lang">on-hit</code> function (which <code class="hljs inline no-lang">searchCallback</code> is passed into) when a search result is selected.</li> <li>Presentation wise, each search result is represented by a <code class="hljs inline no-lang">searchbar-pageitem</code> vue component.</li></ul> <p><strong>SearchbarPageItem.vue</strong></p> <ul><li>Presents the component conditionally based on whether item is a heading or a page title.</li></ul> <h4 id="how-the-new-markbind-pagefind-plugin-works">How the new Markbind PageFind Plugin Works<a href="#how-the-new-markbind-pagefind-plugin-works" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h4> <p>About <a href="https://pagefind.app/">PageFind</a>: A fully static search library that aims to perform well on large sites, while using as little of users bandwidth
as possible, and without hosting any infrastructure.</p> <p><strong>Documentation:</strong></p> <ul><li><a href="https://pagefind.app/docs/node-api/">PageFind NodeJS Indexing API</a></li> <li><a href="https://github.com/CloudCannon/pagefind/blob/production-docs/pagefind_web_js/types/index.d.ts">The types returned by Pagefind’s JavaScript search API</a></li></ul> <h4 id="integration-of-pagefind-into-markbind"><strong>Integration of Pagefind into MarkBind</strong><a href="#integration-of-pagefind-into-markbind" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h4> <p>It runs after the website framework, and only requires the folder containing the built static files of the website. A short explanation of how it works would be:</p> <ul><li>PageFind indexes the static files
<ul><li>If pagefind is included as a plugin, we indexSites with PageFind, which writes the index files  _site/pagefind</li></ul></li> <li>Plugin exposes a pagefind JS API for searching
<ul><li>Alternatively, use pagefind default UI for searching. This is done by processes containers with <code class="hljs inline no-lang">id=&quot;pagefind-search-input&quot;</code>, and initialing a default PageFindUI instance on it, not unlike how algolia search works.</li></ul></li> <li>This JS API is used by a custom Vue component searchbar.</li></ul> <h2 id="external-tools-technology">External Tools/Technology<a href="#external-tools-technology" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h2> <h3 id="vue">Vue<a href="#vue" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <h4 id="vue-2-to-vue-3">Vue 2 to Vue 3<a href="#vue-2-to-vue-3" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h4> <p>I got the chance to experience <a href="https://www.reddit.com/r/vuejs/comments/1bp72k5/vue_2_to_vue_3_upgrade_is_one_of_the_most_painful/">this</a> firsthand.</p> <ul><li>Through the process (ongoing), it has also allowed me to uncover a significant number of bugs in MarkBind.</li></ul> <p><a href="https://v3-migration.vuejs.org/migration-build">https://v3-migration.vuejs.org/migration-build</a></p> <p>MarkBind (v5.5.3) is currently using Vue 2. However, Vue 2 has reached EOL and limits the extensibility and maintainability of MarkBind, especially the vue-components package. (UI Library Package).</p> <p>Vue 2 components can be authored in two different API styles: Option API and Composition API. Read the difference <a href="https://dev.to/sucodelarangela/vue3-options-api-vs-composition-api-en-1fbo#:~:text=However%2C%20with%20the%20release%20of,known%20as%20the%20Options%20API.">here</a> It was interesting to read the difference between the two.</p> <ul><li>The Option API organizes code into predefined options like data, methods, and computed, making it simpler and more beginner-friendly but less flexible for complex logic.</li> <li>In contrast, the Composition API uses a setup() function and reactive utilities like ref and reactive, allowing logic to be grouped by feature for better modularity and reusability. While the Option API relies on mixins for reuse, which can lead to conflicts, the Composition API enables cleaner and more scalable code through composable functions.
<ul><li>Additionally, the Composition API offers superior TypeScript support and is better suited for large, complex applications, though it has a steeper learning curve compared to the straightforward Option API.</li></ul></li></ul> <blockquote><p>Server-side rendering: the migration build can be used for SSR, but migrating a custom SSR setup is much more involved. The general idea is replacing vue-server-renderer with @vue/server-renderer. Vue 3 no longer provides a bundle renderer and it is recommended to use Vue 3 SSR with Vite. If you are using Nuxt.js, it is probably better to wait for Nuxt 3.</p></blockquote> <p>Currently, MarkBind Vue components are authored in the Options API style. If migrated to Vue 3, we can continue to use this API style.</p> <h5 id="vue-2-to-vue-3-biggest-shift">Vue 2 to Vue 3 (Biggest Shift)<a href="#vue-2-to-vue-3-biggest-shift" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h5> <p><strong>Vue 2</strong>
In Vue 2, global configuration is shared across all root instances as concept of &quot;app&quot; not formalized. All Vue instances in the app used the same global configuration, and this could lead to unexpected behaviors if different parts of the application needed different configurations or global directives.</p> <blockquote><p>E.g. global API in Vue 2, like Vue.component() or Vue.directive(), directly mutated the global Vue instance.</p></blockquote> <p>Some of MarkBind's plugins depend on this specific property of Vue 2 (directives, in particular, which are registered after mounting).</p> <p>However, the shift to Vue 3 took into consideration the lack of application boundaries and potential global pollution. Hence, Vue 3 takes a different approach that takes a bit of effort to migrate.</p> <p><strong>Vue 3</strong>
In Vue 3, the introduction of the app instance via <code class="hljs inline no-lang">createApp()</code> changes how global configurations, directives, and components are managed, offering more control and flexibility.</p> <ul><li>The <code class="hljs inline no-lang">createApp()</code> method allows you to instantiate an &quot;app,&quot; providing a boundary for the app's configuration -- Scoped Global Configuration: Instead of mutating the global Vue object, components, directives, or plugins are now registered on a specific app instance.</li></ul> <p>Also some particularities with using Vue 3:</p> <ul><li><a href="https://github.com/vuejs/core/issues/4344">https://github.com/vuejs/core/issues/4344</a></li></ul> <h4 id="vue-sfc-single-file-components">Vue SFC (Single File Components)<a href="#vue-sfc-single-file-components" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h4> <p><a href="https://vuejs.org/guide/scaling-up/sfc.html">Reference</a></p> <blockquote><p>Vue uses an HTML based template syntax. All Vue templates <code class="hljs inline no-lang">&lt;template/&gt;</code> are syntactically valid HTML tht can be parsed by browsers. Under the hood, Vue compiles the template into highly optimized JS code. Using reactivity, Vue figures out minimal number of components to re-render and apply minimal DOM manipulations.</p></blockquote> <p>SFC stands for Single File Components (*.vue files) and is a special file format thaat allows us to encapsulate the template, logic, styling of a Vue component in a single file.</p> <ul><li><p>All <code class="hljs inline no-lang">*.vue</code> files only consist of three parts, <code class="hljs inline no-lang">&lt;template&gt;</code> where HTML content is, <code class="hljs inline no-lang">&lt;script&gt;</code> for Vue code and <code class="hljs inline no-lang">&lt;style&gt;</code>.</p></li> <li><p>SFC requires a build step, but it allows for pre-compiled templates without runtime compilation cost. SFC is a defining feature of Vue as a framework, and is the reccomended approach of using Vue for Static Site Generation and SPA. Needless to say, MarkBind uses Vue SFCs.</p></li> <li><p><code class="hljs inline no-lang">&lt;style&gt;</code> tags inside SFCs are usually injected as native style tags during development to support hot updates, but for production can be extracted and merged into a single CSS file. (which is what Webpack does)</p></li></ul> <h4 id="vue-rendering-mechanism">Vue Rendering Mechanism<a href="#vue-rendering-mechanism" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h4> <p>Reference: <a href="https://vuejs.org/guide/extras/rendering-mechanism">https://vuejs.org/guide/extras/rendering-mechanism</a></p> <p>Terms:</p> <ul><li><code class="hljs inline no-lang">virtual DOM (VDOM)</code> - concept where an ideal 'virtual' DOM representation of UI kept in memory, synced with the 'real' DOM. Adopted by React, Vue, other frontend frameworks.</li> <li><code class="hljs inline no-lang">mount</code>: Runtime renderer walk a virtual DOM tree and construct a real DOM tree from it.</li> <li><code class="hljs inline no-lang">patch</code>: Given two copies of virtual DOM trees, renderer walk and compare the two trees, figure out difference, apply changes to actual DOM.</li></ul> <p>The VDOM gives the ability to programmatically create inspect and compose desired UI structures in a declarative way (and leave direct DOM manipulation to renderer).</p> <p><em><strong>Render Pipeline</strong></em>
What happens when Vue Component is Mounted:</p> <ol><li><strong>Compile</strong>: Vue template compiled into render function, functions that return VDOM trees. (Done ahead of time in MarkBind)</li> <li><strong>Mount</strong>: Runtime renderer invoke render function, walks VDOM, creates actual DOM node.</li> <li><strong>Patch</strong>: When dependency used during mount changes, effect re-runs, new updated VDOM created. Then, patch the actual DOM.</li></ol> <h4 id="vue-server-side-rendering-ssr">Vue Server Side Rendering (SSR)<a href="#vue-server-side-rendering-ssr" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h4> <p>It is possible to render the Vue components into HTML strings on the server, send directly to the browser and finally 'hydrate' static markup into fully interactive app on the client.</p> <p>Advantages of SSR:</p> <ul><li>Faster time to content, especially on slower devices</li> <li>Unified Mental Model using same language and same declarative</li> <li>Better SEO since crawlers see fully rendered page</li></ul> <h5 id="roles-of-server-and-client-in-ssr">Roles of Server and Client in SSR:<a href="#roles-of-server-and-client-in-ssr" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h5> <p><strong>SSR:</strong> The server's job is to:</p> <ul><li>Compile the Vue template into a render function.</li> <li>Use the render function to generate static HTML.</li> <li>Send the static HTML to the browser.</li></ul> <p><strong>Client-Side Hydration</strong>: Once the browser receives the static HTML from the server, the client-side Vue app takes over. Its job is to:</p> <ul><li>Attach event listeners and reactivity to the static HTML.</li> <li>Make the app interactive (e.g., responding to user actions like clicks or input).</li></ul> <p><strong>Vue 3 <code class="hljs inline no-lang">createApp() vs createSSRApp()</code></strong> <code class="hljs inline no-lang">createApp</code> does not bother with hydration. It assumes direct access to the DOM, creates and inserts its rendered HTML. <code class="hljs inline no-lang">createSSRApp()</code> used for creating Vue application instance specifically for SSR, where inital HTML is rendered on the server and sent to client for hydration. Instead of rendering (creating and inserting whole HTML from scratch), it does patching. It also does initialization by setting up reactivity, components, global properties etc, event binding during the mount process (aka Hydration).</p> <h3 id="external-packages-used-by-markbind">External Packages used by MarkBind<a href="#external-packages-used-by-markbind" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <ul><li><code class="hljs inline no-lang">live-server</code> – A simple development server with live reloading functionality, used to automatically refresh the browser when changes are made to MarkBind projects.</li> <li><code class="hljs inline no-lang">commander.js</code> – A command-line argument parser for Node.js, used to define and handle CLI commands in MarkBind.</li> <li><code class="hljs inline no-lang">fs</code> (Node.js built-in) – The File System module, used for reading, writing, and managing files and directories in MarkBind projects.</li> <li><code class="hljs inline no-lang">lodash</code> – A utility library providing helper functions for working with arrays, objects, and other JavaScript data structures, improving code efficiency and readability in MarkBind</li></ul> <h3 id="research-on-other-ssgs">Research on Other SSGs<a href="#research-on-other-ssgs" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <p>While working on Markbind, I thought that it would definitely be essential to survey other Static Site Generators and the competition faced by MarkBind.</p> <p>Researching other SSGs available (many of which are open source as well) has allowed me to gain a broader picture of the roadmap of MarkBind.</p> <p>For example, Jekyll is simple and beginner-friendly, often paired with GitHub Pages for easy deployment. It has a large theme ecosystem for rapid site creation. Hugo has exceptional build speeds even for large sites. Other SSGs offer multiple rendering modes (SSG, SSR, CSR) on a per page basis, support react etc. Considering that the community for all these other SSGs are much larger and they have much more resources and manpower to devote, I thought about how MarkBind could learn from these other SSGs.</p> <h4 id="insights-that-could-be-applied-to-markbind">Insights that could be applied to MarkBind<a href="#insights-that-could-be-applied-to-markbind" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h4> <p>Overall, some insights that can be applied to MarkBind would be to:</p> <ul><li>Focus on Content-Heavy Instructional Websites
<ul><li>Double down on features tailored for educational, project documentation, and course websites.</li> <li>Highlight built-in components like popovers, tabs, and collapsible panels as unique differentiators.</li></ul></li> <li>Emphasize &quot;Out-of-the-Box&quot; Functionality
<ul><li>Simplify onboarding and documentation for new users.</li> <li>Provide all essential features for documentation by default (e.g., diagrams, code snippets, multi-level navigation).</li> <li>Position MarkBind as a solution that minimizes configuration while maximizing flexibility.</li> <li>Provide beginner-friendly guides and videos for quick adoption.</li></ul></li> <li>Develop Pre-Built Templates
<ul><li>Create specialized templates for use cases like course sites, research documentation, or user guides.</li> <li>Create ready-made themes/templates focused on education and documentation.</li> <li>Allow users to deploy quickly with minimal setup.</li></ul></li></ul> <h3 id="general-development-knowledge">General Development Knowledge<a href="#general-development-knowledge" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <h4 id="commonjs-and-esm">CommonJS and ESM<a href="#commonjs-and-esm" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h4> <p>CommonJS (CJS) is the older type of modules and CJS were the only supported style of modules in NodeJS up till v12.</p> <ul><li>Use the syntax <code class="hljs inline no-lang">require</code> and <code class="hljs inline no-lang">module.exports = {XX:{},}</code></li> <li>Global, synchronouse require function added to import other odules.</li> <li>mark the file as a CJS module by naming as <code class="hljs inline no-lang">.cjs</code> or by using type <code class="hljs inline no-lang">commonjs</code> in package.json.</li></ul> <p>EcmaScript Modules (ESM) standardized later and are the only natively supported module style in browsers. It is the (EcmaScript standard) JS standard way of writing modules/</p> <ul><li>use <code class="hljs inline no-lang">import { XXX } from YYY</code> (top of file), <code class="hljs inline no-lang">const { ZZ } = await import(&quot;CCC&quot;);</code> and <code class="hljs inline no-lang">export const XXX = {}</code>.</li> <li>Syntax addition to JS and allows to easily import and export static members.</li></ul> <p>Issues I faced:</p> <ul><li>I didn't realize tha my TypeScript code was being compiled to CommonJS (<code class="hljs inline no-lang">require</code>) instead of ES module syntax (<code class="hljs inline no-lang">import</code>), and hence <code class="hljs inline no-lang">import</code> was not working correctly.</li> <li>Had to change the <code class="hljs inline no-lang">tsconfig.json</code> settings appropriately.</li></ul> <h4 id="classic-scripts-vs-module-scripts-in-js">Classic Scripts vs Module Scripts in JS<a href="#classic-scripts-vs-module-scripts-in-js" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h4> <p>JavaScript offers two script types: <strong>module</strong> and <strong>non-module</strong>.  (For web pages, JavaScript is the Prog. Lang for the web after all).</p> <p><strong>Module Script Files</strong>: use ES Modules (<code class="hljs inline no-lang">import</code>/<code class="hljs inline no-lang">export</code>), run in strict mode, and have local scope, making them ideal for modern, modular applications. They load asynchronously and are supported in modern browsers and Node.js (with <code class="hljs inline no-lang">.mjs</code> or <code class="hljs inline no-lang">&quot;type&quot;: &quot;module&quot;</code>).</p> <ul><li><strong>Scope</strong>: Local (encapsulated)</li> <li><strong>Execution</strong>: Strict mode by default</li> <li><strong>Loading</strong>: Asynchronous, deferred</li> <li><strong>Reusability</strong>: High (modular)</li> <li><strong>Browser Support</strong>: Modern browsers</li> <li><strong>Node.js</strong>: Native (<code class="hljs inline no-lang">.mjs</code> or <code class="hljs inline no-lang">&quot;type&quot;: &quot;module&quot;</code>)</li></ul> <p><strong>Non-Module Script File</strong> rely on global scope, lack strict mode by default, and load synchronously. They work in all browsers and use CommonJS (<code class="hljs inline no-lang">require</code>) in Node.js, making them suitable for legacy projects or simple scripts.</p> <ul><li><strong>Syntax</strong>: No <code class="hljs inline no-lang">import</code>/<code class="hljs inline no-lang">export</code></li> <li><strong>Scope</strong>: Global (pollution risk)</li> <li><strong>Execution</strong>: Non-strict by default</li> <li><strong>Loading</strong>: Synchronous by default</li> <li><strong>Reusability</strong>: Low (global dependencies)</li> <li><strong>Browser Support</strong>: All browsers</li> <li><strong>Node.js</strong>: CommonJS (<code class="hljs inline no-lang">require</code>)</li></ul> <p>Use <strong>modules</strong> for modern, scalable apps and <strong>non-modules</strong> for legacy compatibility or simpler use cases. Transition to modules for better maintainability.</p> <h3 id="typescript">TypeScript<a href="#typescript" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <p>TypeScript has two main kinds of files. <code class="hljs inline no-lang">.ts</code> files are implementation files that contain types and executable code. These are the files that produce <code class="hljs inline no-lang">.js</code> outputs, and are where you normally write your code. <code class="hljs inline no-lang">.d.ts</code> files are declaration files that contain only type information. These files don’t produce <code class="hljs inline no-lang">.js</code> outputs; they are only used for typechecking.</p> <ul><li><p>DefinitelyTyped / <code class="hljs inline no-lang">@types</code>: The DefinitelyTyped repository is a centralized repo storing declaration files for thousands of libraries. The vast majority of commonly-used libraries have declaration files available on DefinitelyTyped.</p></li> <li><p><strong>Declaration Maps</strong>: <code class="hljs inline no-lang">.d.ts.map</code> Declaration map (.d.ts.map) files also known as declaration source maps, contain mapping definitions that link each type declaration generated in .d.ts files back to your original source file (.ts). The mapping definition in these files are in JSON format.</p> <ul><li>This is helpful in code navigation. This enables editor features like “Go to Definition” and Rename to transparently navigate and edit code across sub projects when you have split a big project into small multiple projects using project references.</li></ul></li></ul></div> <nav id="page-nav" class="fixed-header-padding" data-v-e6005420><div class="nav-component slim-scroll" data-v-e6005420></div> <!----></nav></div> <footer><div class="text-center"><p>[<strong>This site was generated using <img src="https://markbind.org/favicon.ico" width="25"> <a href="https://markbind.org/">MarkBind 5.6.0</a></strong> on Mon, 7 Apr 2025, 12:49:14 UTC]<br> <span class="dimmed"><small><small>favicon.ico of this site was made by <a href="https://www.flaticon.com/authors/smashicons" title="Smashicons">Smashicons</a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com</a> is licensed by <a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons BY 3.0" target="_blank">CC 3.0 BY</a></small></small></span></p></div></footer></div>
</body><script src="/2025/markbind/js/bootstrap-utility.min.js"></script>
<script src="/2025/markbind/js/polyfill.min.js"></script>
<script src="/2025/markbind/js/vue.min.js"></script>
<script src="/2025/markbind/js/markbind.min.js"></script>
<script src="knowledge.page-vue-render.js"></script>
<script>
  MarkBind.setupWithSearch()
</script>
</html>
